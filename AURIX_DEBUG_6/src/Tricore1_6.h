//****************************************************************************
// @Module        TriCore Instriction Set for TC1.6
// @Filename      Tricore1_6.h
// @Project       AURIX Debugger
//----------------------------------------------------------------------------


#ifndef __TC1_6_h
#define __TC1_6_h

/******************************************************************************
**                      Include Files                                        **
******************************************************************************/

#include "mcd_types.h"

/*
  This is a C interface, not a C++ interface.
*/
#ifdef __cplusplus
extern "C" {
#endif

/******************************************************************************
** DEFINES                                                                   **
******************************************************************************/

#define NUMOPCODES	512		// Number of Tricore 1.6 Opcodes
#define INSTSTRSIZE	12		// Size of Instruction description
#define DESCSRSIZE	48		// Size of Instruction short description
#define DESCLRSIZE	196		// Size of Instruction long description


/******************************************************************************
** TYPEDEF                                                                   **
******************************************************************************/

typedef struct deASM_n
{
    uint32_t uiOpCode;			// Opcode (e.g. 0xDC for 'ji')
    uint8_t uiOpCodeLengh;		// Lenght of the opcode (e.g. 16)
	char sInStr[INSTSTRSIZE];	// Instruction Mnemonic
	char sLongName[DESCSRSIZE];	// Instruction Longname
	char sSyntax[DESCSRSIZE];	// Instruction Syntax
	char sLDescr[DESCLRSIZE];	// Instruction Long Description
} deASM_t;


/******************************************************************************
** STATIC VARIBLES                                                           **
******************************************************************************/
/* Deassembler look-up table, based on: https://www.infineon.com/dgdl/Infineon-TC2xx_Architecture_vol2-UM-v01_00-EN.pdf?fileId=5546d46269bda8df0169ca1bf33124a8 */
extern deASM_t tc16[NUMOPCODES] = {
    {0x3B, 32, "MOVD", "Move", "MOV D[c], const16", "Move the contents to data register"},
	{0x4E, 16, "JGTZ", "Jump if Greater Than Zero", "JGTZ D[b], disp4", "If the contents of D[b] are greater than zero, then add the value specified by disp4, zero-extended and multiplied by 2, to the contents of PC and jump to that address"},
	{0x54, 16, "LD.W", "Load Word", "LD.W D[c], A[b]", "Load word contents of the memory location specified by the addressing mode into data register D[a]"},
	{0x8E, 16, "JLEZ", "Jump if Less Than or Equal to Zero", "JLEZ D[b], disp4", "If the contents of D[b] are less than or equal to zero, then add the value specified by disp4, zero-extended and multiplied by 2, to the contents of PC and jump to that address"},
	{0x091, 32, "MOVH.A", "Move High to Address", "MOVH.A A[c], const16", "Move the value const16 to the most-significant half-word of address register A[c] and set the least-significant 16-bits to zero"},
	{0xCE, 16, "JGEZ", "Jump if Greater Than or Equal to Zero", "JGEZ D[b], disp4", "If the contents of D[b] are greater than or equal to zero, then add the value specified by disp4, zero-extended and multiplied by 2, to the contents of PC and jump to that address"},
	{0xCD, 32, "MTCR", "Move To Core Register", "MTCR const16, D[a]", "Move the value in data register D[a] to the Core Special Function Register (CSFR) selected by the value const16. Supervisor mode only!"},
	{0x02800049, 32, "LEA", "Load Effective Address", "LEA A[a], A[b], off10", "Compute the absolute (effective) address defined by the addressing mode and put the result in address register A[a]"},
	{0x000000C5, 32, "LEA", "Load Effective Address", "LEA A[a], off18 (ABS)", "Compute the absolute (effective) address defined by the addressing mode and put the result in address register A[a]"},
	{0xD9, 32,		 "LEA", "Load Effective Address", "LEA A[a], A[b], off16", "Compute the absolute (effective) address defined by the addressing mode and put the result in address register A[a]"},
	{0xDA, 16, "MOV", "Move", "MOV D[15], const8", "Move the contents of const8 to data register D[15]. The value const8 is zero-extended before it is moved. "},
	{0xDC, 16, "JIA", "Jump Indirect", "JI A[a]", "Load the contents of address register A[a] into PC and jump to that address. The least-significant bit is always set to 0"},
	{0xDD, 32, "JLA", "Jump and Link Absolute","JLA disp24", "Store the address of the next instruction in A[11] (return address). Load the value specified by disp24 into PC and  jump to that address"},
	{0x6E, 16, "JZ", "Jump if Zero", "JZ D[15], disp8", "If contents of D[15] is equal to zero, then add value specified by disp8, sign-extended and multiplied by 2, to the contents of PC and jump to that address."},
	{0x76, 16, "JZ", "Jump if Zero", "JZ D[b], disp4", "If contents of D[b] is equal to zero, then add value specified by disp4,  zero-extended and multiplied by 2, to the contents of PC and jump to that address."},
	{0xEE, 16, "JNZ", "Jump if Not Equal to Zero", "JNZ D[15], disp8", "If contents of D[15] is not equal to zero, then add value specified by disp8, sign-extended and multiplied by 2, to the contents of PC and jump to that address."},
	{0xF6, 16, "JNZ", "Jump if Not Equal to Zero", "JNZ D[b], disp4", "If contents of D[b] is not equal to zero, then add value specified by disp4,  zero-extended and multiplied by 2, to the contents of PC and jump to that address."},

	{0x00600037, 32, "EXTR", "Extract Bit Field", "EXTR.U D[c], D[a], pos, width", "Extract the number of consecutive bits"},
	{0x00400037, 32, "EXTR", "Extract Bit Field", "EXTR D[c], D[a], pos, width", "Extract the number of consecutive bits"},


	{0x01E0000F, 32, "ORN", "Bitwise OR-Not", "ORN D[c], D[a], D[b]", "Compute the bitwise OR of the contents of data register and the ones’ complement of the contents [..]"},
	{0x01E0008F, 32, "ORN", "Bitwise OR-Not", "ORN D[c], D[a], const9", "Compute the bitwise OR of the contents of data register and the ones’ complement of the contents [..]"},

	{0x01C0000F, 32, "ANDN", "Bitwise AND-Not", "ANDN D[c], D[a], D[b]", "Compute the bitwise AND of the contents of data register and the ones complement of the contents [..]"},
	{0x01C0008F, 32, "ANDN", "Bitwise AND-Not", "ANDN D[c], D[a], const9", "Compute the bitwise AND of the contents of data register and the ones complement of the contents [..]"},

	{0x01A0000F, 32, "XNOR", "Bitwise XNOR", "XNOR D[c], D[a], D[b]", "Compute the bitwise exclusive NOR of the contents of data register [..]"},
	{0x01A0008F, 32, "XNOR", "Bitwise XNOR", "XNOR D[c], D[a], const9", "Compute the bitwise exclusive NOR of the contents of data register [..]"},

	{0x0160000F, 32, "NOR", "Bitwise NOR", "NOR D[c], D[a], D[b]", "Compute the bitwise NOR of the contents of data register [..]"},
	{0x0160008F, 32, "NOR", "Bitwise NOR", "NOR D[c], D[a], const9", "Compute the bitwise NOR of the contents of data register [..]"},

	{0x0140000F, 32, "OR", "Bitwise OR", "OR D[c], D[a], D[b]", "Compute the bitwise OR of the contents of data register [..]"},
	{0x0140008F, 32, "OR", "Bitwise OR", "OR D[c], D[a], const9", "Compute the bitwise OR of the contents of data register [..]"},

	{0x0120000F, 32, "NAND", "Bitwise NAND", "NAND D[c], D[a], D[b]", "Compute the bitwise NAND of the contents of data register [..]"},
	{0x0120008F, 32, "NAND", "Bitwise NAND", "NAND D[c], D[a], const9", "Compute the bitwise NAND of the contents of data register [..]"},

	{0x0100000F, 32, "AND", "Bitwise AND", "AND D[c], D[a], D[b]", "Compute the bitwise AND of the contents of data register [..]"},
	{0x0100008F, 32, "AND", "Bitwise AND", "AND D[c], D[a], const9", "Compute the bitwise AND of the contents of data register [..]"},

	{0x0000000F, 32, "SH", "Shift", "SH D[c], D[a], D[b]", "Shift the value by the amount specified by shift count [..]"},
	{0x0000008F, 32, "SH", "Shift", "SH D[c], D[a], const9", "Shift the value by the amount specified by shift count[..]"},

    {0x01C0000B, 32, "ABS", "Absolute Value", "ABS D[c], D[b]", "See pag.49"},
    {0x05C0000B, 32, "ABS.B", "Absolute Value Packed Byte", "ABS.B D[c], D[b]", "See pag.50"},
    {0x07C0000B, 32, "ABS.H", "Absolute Value Packed Half-word", "ABS.H D[c], D[b]", "See pag.50"},
    {0x00E0008B, 32, "ABSDIF", "Absolute Value of Difference", "ABSDIF D[c], D[a], const9", "See pag.52"},
    {0x00E0008B, 32, "ABSDIF", "Absolute Value of Difference", "ABSDIF D[c], D[a], D[b]", "See pag.52"},
    {0x04E0000B, 32, "ABSDIF.B", "Absolute Value of Difference Packed Byte", "ABSDIF.B D[c], D[a], D[b]", "See pag.53"},
    {0x06E0000B, 32, "ABSDIF.H", "Absolute Value of Difference Packed Half-word", "ABSDIF.H D[c], D[a], D[b]", "See pag.53"},
    {0x00F0008B, 32, "ABSDIFS", "Absolute Value of Difference with Saturation", "ABSDIFS D[c], D[a], const9", "See pag.55"},
    {0x00F0000B, 32, "ABSDIFS", "Absolute Value of Difference with Saturation", "ABSDIFS D[c], D[a], D[b]", "See pag.55"},
    {0x06F0000B, 32, "ABSDIFS.H", "Absolute Value of Difference Packed Half-word", "ABSDIFS.H D[c], D[a], D[b]", "See pag.56"},
    {0x01D0000B, 32, "ABSS", "Absolute Value with Saturation", "ABSS D[c], D[b]", "See pag.57"},
    {0x07D0000B, 32, "ABSS.H", "Absolute Value Packed Half-word with Saturatio", "ABSS.H D[c], D[b]", "See pag.58"},
    {0x0000008B, 32, "ADD", "Add", "ADD D[c], D[a], const9", "See pag.59"},
    {0x0000000B, 32, "ADD", "Add", "ADD D[c], D[a], D[b]", "See pag.59"},
    {0xC2, 16, "ADD", "Add", "ADD D[a], const4", "See pag.59"},
    {0x92, 16, "ADD", "Add", "ADD D[a], D[15], const4", "See pag.59"},
    {0x9A, 16, "ADD", "Add", "ADD D[15], D[a], const4", "See pag.59"},
    {0x42, 16, "ADD", "Add", "ADD D[a], D[b]", "See pag.60"},
    {0x12, 16, "ADD", "Add", "ADD D[a], D[15], D[b]", "See pag.60"},
    {0x1A, 16, "ADD", "Add", "ADD D[15], D[a], D[b] (SRR)", "See pag.60"},
    {0x00100001, 32, "ADD.A", "Add Address", "ADD.A A[c], A[a], A[b]", "See pag.62"},
    {0xB0, 16, "ADD.A", "Add Address", "ADD.A A[a], const4 (SRC)", "See pag.62"},
    {0x30, 16, "ADD.A", "Add Address", "ADD.A A[a], A[b] (SRR)", "See pag.62"},
    {0x0400000B, 32, "ADD.B", "Add Packed Byte", "ADD.B D[c], D[a], D[b]", "See pag.63"},
    {0x0600000B, 32, "ADD.H", "Add Packed Half-word", "ADD.H D[c], D[a], D[b]", "See pag.63"},
    {0x0050008B, 32, "ADDC", "Add with Carry", "ADDC D[c], D[a], const9", "See pag.65"},
    {0x0050000B, 32, "ADDC", "Add with Carry", "ADDC D[c], D[a], D[b]", "See pag.65"},
    {0x1B, 32, "ADDI", "Add Immediate", "ADDI D[c], D[a], const16 (RLC)", "See pag.66"},
    {0x9B, 32, "ADDIH", "Add Immediate High", "ADDIH D[c], D[a], const16 (RLC)", "See pag.67"},
    {0x11, 32, "ADDIH.A", "Add Immediate High to Address", "ADDIH.A A[c], A[a], const16 (RLC)", "See pag.68"},
    {0x0020008B, 32, "ADDS", "Add Signed with Saturation", "ADDS D[c], D[a], const9", "See pag.69"},
    {0x0020000B, 32, "ADDS", "Add Signed with Saturation", "ADDS D[c], D[a], D[b]", "See pag.69"},
    {0x22, 16, "ADDS", "Add Signed with Saturation", "ADDS D[a], D[b], (SRR)", "See pag.69"},
    {0x0620000B, 32, "ADDS.H", "Add Signed Packed Half-word with Saturation", "ADDS.H D[c], D[a], D[b]", "See pag.71"},
    {0x0630000B, 32, "ADDS.HU", "Add Unsigned Packed Half-word with Saturation", "ADDS.HU D[c], D[a], D[b]", "See pag.71"},
    {0x0030008B, 32, "ADDS.U", "Add Unsigned with Saturation", "ADDS.U D[c], D[a], const9", "See pag.73"},
    {0x0030000B, 32, "ADDS.U", "Add Unsigned with Saturation", "ADDS.U D[c], D[a], D[b]", "See pag.73"},
    {0x06000001, 32, "ADDSC.A", "Add Scaled Index to Address", "ADDSC.A A[c], A[b], D[a], n", "See pag.74"},
    {0x10, 16, "ADDSC.A", "Add Scaled Index to Address", "ADDSC.A A[a], A[b], D[15], n (SRRS)", "See pag.74"},
    {0x06200001, 32, "ADDSC.AT", "Add Bit-Scaled Index to Address", "ADDSC.AT A[c], A[b], D[a]", "See pag.74"},
    {0x0040008B, 32, "ADDX", "Add Extended", "ADDX D[c], D[a], const9", "See pag.76"},
    {0x0040000B, 32, "ADDX", "Add Extended", "ADDX D[c], D[a], D[b]", "See pag.76"},
    {0x0080008F, 32, "AND", "Bitwise AND", "AND D[c], D[a], const9", "See pag.77"},
    {0x0080000F, 32, "AND", "Bitwise AND", "AND D[c], D[a], D[b]", "See pag.77"},
    {0x16, 16, "AND", "Bitwise AND", "AND D[15], const8 (SC)", "See pag.77"},
    {0x26, 16, "AND", "Bitwise AND", "AND D[a], D[b] (SRR)", "See pag.77"},
    {0x00000047, 32, "AND.AND.T", "Accumulating Bit Logical AND-AND", "AND.AND.T D[c], D[a], pos1, D[b], pos2 (BIT)", "See pag.79"},
    {0x00300047, 32, "AND.ANDN.T", "Accumulating Bit Logical AND-AND-Not", "AND.ANDN.T D[c], D[a,] pos1, D[b], pos2 (BIT)", "See pag.79"},
    {0x00200047, 32, "AND.NOR.T", "Accumulating Bit Logical AND-NOR", "AND.NOR.T D[c], D[a], pos1, D[b], pos2 (BIT)", "See pag.79"},
    {0x00100047, 32, "AND.OR.T", "Accumulating Bit Logical AND-OR", "AND.OR.T D[c], D[a], pos1, D[b], pos2 (BIT)", "See pag.79"},
    {0x0200008B, 32, "AND.EQ", "Equal Accumulating", "AND.EQ D[c], D[a], const9", "See pag.81"},
    {0x0200000B, 32, "AND.EQ", "Equal Accumulating", "AND.EQ D[c], D[a], D[b]", "See pag.81"},
    {0x0240008B, 32, "AND.GE", "Greater Than or Equal Accumulating", "AND.GE D[c], D[a], const9", "See pag.82"},
    {0x0240000B, 32, "AND.GE", "Greater Than or Equal Accumulating", "AND.GE D[c], D[a], D[b]", "See pag.82"},
    {0x0250008B, 32, "AND.GE.U", "Greater Than or Equal Accumulating Unsigned", "AND.GE.U D[c], D[a], const9", "See pag.82"},
    {0x0250000B, 32, "AND.GE.U", "Greater Than or Equal Accumulating Unsigned", "AND.GE.U D[c], D[a], D[b]", "See pag.82"},
    {0x0220008B, 32, "AND.LT", "Less Than Accumulating", "AND.LT D[c], D[a], const9", "See pag.84"},
    {0x0220000B, 32, "AND.LT", "Less Than Accumulating", "AND.LT D[c], D[a], D[b]", "See pag.84"},
    {0x0230008B, 32, "AND.LT.U", "Less Than Accumulating Unsigned", "AND.LT.U D[c], D[a], const9", "See pag.84"},
    {0x0230000B, 32, "AND.LT.U", "Less Than Accumulating Unsigned", "AND.LT.U D[c], D[a], D[b]", "See pag.84"},
    {0x0210008B, 32, "AND.NE", "Not Equal Accumulating", "AND.NE D[c], D[a], const9", "See pag.86"},
    {0x0210000B, 32, "AND.NE", "Not Equal Accumulating", "AND.NE D[c], D[a], D[b]", "See pag.86"},
    {0x00000087, 32, "AND.T", "Bit Logical AND", "AND.T D[c], D[a], pos1, D[b], pos2 (BIT)", "See pag.87"},
    {0x00E0008F, 32, "ANDN", "Bitwise AND-Not", "ANDN D[c], D[a], const9", "See pag.88"},
    {0x00E0000F, 32, "ANDN", "Bitwise AND-Not", "ANDN D[c], D[a], D[b]", "See pag.88"},
    {0x87, 32, "ANDN.T", "Bit Logical AND-Not", "ANDN.T D[c], D[a], pos1, D[b], pos2", "See pag.89"},
    {0xAD, 32, "BISR", "Begin Interrupt Service Routine", "BISR const9", "See pag.90"},
    {0xE0, 16, "BISR", "Begin Interrupt Service Routine", "BISR const8", "See pag.90"},
    {0x4B, 32, "BMERGE", "Bit Merge", "BMERGE D[c], D[a], D[b]", "See pag.92"},
    {0x4B, 32, "BSPLIT", "Bit Split", "BSPLIT E[c], D[a]", "See pag.93"},
    {0x89, 32, "CACHEA.I", "Cache Address, Invalidate", "CACHEA.I A[b], off10 (BO) (Base + Short Offset", "See pag.94"},
    {0xA9, 32, "CACHEA.I", "Cache Address, Invalidate", "CACHEA.IP[b]", "See pag.94"},
    {0xA9, 32, "CACHEA.I", "Cache Address, Invalidate", "CACHEA.IP[b], off10 (BO) (Circular Addressing", "See pag.94"},
    {0x89, 32, "CACHEA.I", "Cache Address, Invalidate", "CACHEA.IA[b], off10 (BO) (Post-increment Addre", "See pag.95"},
    {0x89, 32, "CACHEA.I", "Cache Address, Invalidate", "CACHEA.IA[b], off10 (BO) (Pre-increment Addres", "See pag.95"},
    {0x89, 32, "CACHEA.W", "Cache Address, Writeback", "CACHEA.WA[b], off10 (BO) (Base + Short Offset", "See pag.96"},
    {0xA9, 32, "CACHEA.W", "Cache Address, Writeback", "CACHEA.WP[b] (BO) (Bit-reverse Addressing Mode", "See pag.96"},
    {0xA9, 32, "CACHEA.W", "Cache Address, Writeback", "CACHEA.WP[b], off10 (BO)(Circular Addressing M", "See pag.96"},
    {0x89, 32, "CACHEA.W", "Cache Address, Writeback", "CACHEA.WA[b], off10 (BO) (Post-increment Addre", "See pag.97"},
    {0x89, 32, "CACHEA.W", "Cache Address, Writeback", "CACHEA.WA[b], off10 (BO) (Pre-increment Addres", "See pag.97"},
    {0x89, 32, "CACHEA.WI", "Cache Address, Writeback and Invalidate", "CACHEA.WIA[b], off10 (BO)(Base + Short Offset", "See pag.98"},
    {0xA9, 32, "CACHEA.WI", "Cache Address, Writeback and Invalidate", "CACHEA.WIP[b] (BO)(Bit-reverse Addressing Mode", "See pag.98"},
    {0xA9, 32, "CACHEA.WI", "Cache Address, Writeback and Invalidate", "CACHEA.WIP[b], off10 (BO) (Circular Addressing", "See pag.98"},
    {0x89, 32, "CACHEA.WI", "Cache Address, Writeback and Invalidate", "CACHEA.WIA[b], off10 (BO)(Post-increment Addre", "See pag.99"},
    {0x89, 32, "CACHEA.WI", "Cache Address, Writeback and Invalidate", "CACHEA.WIA[b], off10 (BO)(Pre-increment Addres", "See pag.99"},
    {0x89, 32, "CACHEI.W", "Cache Index, Writeback", "CACHEI.WA[b], off10 (BO)(Base + Short Offset A", "See pag.100"},
    {0x90, 32, "CACHEI.W", "Cache Index, Writeback", "CACHEI.WA[b], off10 (BO)(Post-increment Addres", "See pag.100"},
    {0x91, 32, "CACHEI.W", "Cache Index, Writeback", "CACHEI.WA[b], off10 (BO)(Post-increment Addres", "See pag.100"},
    {0x89, 32, "CACHEI.I", "Cache Index, Invalidate", "CACHEI.IA[b], off10 (BO)(Base + Short Offset A", "See pag.102"},
    {0x89, 32, "CACHEI.I", "Cache Index, Invalidate", "CACHEI.IA[b], off10 (BO)(Post-increment Addres", "See pag.102"},
    {0x89, 32, "CACHEI.I", "Cache Index, Invalidate", "CACHEI.IA[b], off10 (BO)(Pre-increment Address", "See pag.102"},
    {0x89, 32, "CACHEI.WI", "Cache Index, Writeback, Invalidate", "CACHEI.WIA[b], off10 (BO)(Base + Short Offset", "See pag.104"},
    {0x89, 32, "CACHEI.WI", "Cache Index, Writeback, Invalidate", "CACHEI.WIA[b], off10 (BO)(Post-increment Addre", "See pag.104"},
    {0x89, 32, "CACHEI.WI", "Cache Index, Writeback, Invalidate", "CACHEI.WIA[b], off10 (BO)(Pre-increment Addres", "See pag.104"},
    {0xAB, 32, "CADD", "Conditional Add", "CADDD[c], D[d], D[a], const9 (RCR)", "See pag.106"},
    {0x2B, 32, "CADD", "Conditional Add", "CADDD[c], D[d], D[a], D[b] (RRR)", "See pag.106"},
    {0x8A, 16, "CADD", "Conditional Add", "CADDD[a], D[15], const4 (SRC)", "See pag.106"},
    {0xAB, 32, "CADDN", "Conditional Add-Not", "CADDND[c], D[d], D[a], const9 (RCR)", "See pag.108"},
    {0x2B, 32, "CADDN", "Conditional Add-Not", "CADDND[c], D[d], D[a], D[b] (RRR)", "See pag.108"},
    {0xCA, 16, "CADDN", "Conditional Add-Not", "CADDND[a], D[15], const4 (SRC)", "See pag.108"},
    {0x6D, 32, "CALL", "Call", "CALLdisp24 (B)", "See pag.110"},
    {0xED, 32, "CALLA", "Call Absolute", "CALLAdisp24 (B)", "See pag.112"},
    {0x2D, 32, "CALLI", "Call Indirect", "CALLIA[a]", "See pag.113"},
    {0x0F, 32, "CLO", "Count Leading Ones", "CLOD[c], D[a]", "See pag.115"},
    {0x0F, 32, "CLO.H", "Count Leading Ones in Packed Half-words", "CLO.HD[c], D[a]", "See pag.116"},
    {0x0F, 32, "CLS", "Count Leading Signs", "CLSD[c], D[a]", "See pag.117"},
    {0x0F, 32, "CLS.H", "Count Leading Signs in Packed Half-words", "CLS.HD[c], D[a]", "See pag.118"},
    {0x0F, 32, "CLZ", "Count Leading Zeros", "CLZD[c], D[a]", "See pag.119"},
    {0x0F, 32, "CLZ.H", "Count Leading Zeros in Packed Half-words", "CLZ.HD[c], D[a]", "See pag.120"},
    {0xAA, 16, "CMOV", "Conditional Move (16-bit)", "CMOVD[a], D[15], const4 (SRC)", "See pag.121"},
    {0x2A, 16, "CMOV", "Conditional Move (16-bit)", "CMOVD[a], D[15], D[b] (SRR)", "See pag.121"},
    {0xEA, 16, "CMOVN", "Conditional Move-Not (16-bit)", "CMOVND[a], D[15], const4 (SRC)", "See pag.122"},
    {0x6A, 16, "CMOVN", "Conditional Move-Not (16-bit)", "CMOVND[a], D[15], D[b] (SRR)", "See pag.122"},
    {0x49, 32, "CMPSWAP.W", "Compare and Swap", "CMPSWAP.WA[b], off10, E[a] (BO)(Base + Short O", "See pag.123"},
    {0x69, 32, "CMPSWAP.W", "Compare and Swap", "CMPSWAP.WP[b], E[a] (BO)(Bit-reverse Addressin", "See pag.123"},
    {0x69, 32, "CMPSWAP.W", "Compare and Swap", "CMPSWAP.WP[b], off10, E[a] (BO)(Circular Addre", "See pag.123"},
    {0x49, 32, "CMPSWAP.W", "Compare and Swap", "CMPSWAP.WA[b], off10, E[a] (BO)(Post-increment", "See pag.123"},
    {0x49, 32, "CMPSWAP.W", "Compare and Swap", "CMPSWAP.WA[b], off10, E[a] (BO)(Pre-increment", "See pag.123"},
    {0x4B, 32, "CRC32", "CRC32", "CRC32D[c], D[b], D[a]", "See pag.125"},
    {0x2B, 32, "CSUB", "Conditional Subtract", "CSUBD[c], D[d], D[a], D[b] (RRR)", "See pag.126"},
    {0x2B, 32, "CSUBN", "Conditional Subtract-Not", "CSUBND[c], D[d], D[a], D[b] (RRR)", "See pag.127"},
    {0x00, 16, "DEBUG", "Debug", "DEBUG(SR)", "See pag.128"},
    {0x0D, 32, "DEBUG", "Debug", "DEBUG(SYS)", "See pag.128"},
    {0x77, 32, "DEXTR", "Extract from Double Register", "Extract 32-bits from registers {D[a], D[b]}, w", "See pag.129"},
    {0x17, 32, "DEXTR", "Extract from Double Register", "DEXTRD[c], D[a], D[b], D[d] (RRRR)", "See pag.129"},
    {0x0D, 32, "DISABLE", "Disable Interrupts", "DISABLE(SYS)", "See pag.130"},
    {0x0D, 32, "DISABLE", "Disable Interrupts", "DISABLED[a] (SYS)", "See pag.130"},
    {0x0D, 32, "DSYNC", "Synchronize Data", "DSYNC(SYS)", "See pag.131"},
    {0x6B, 32, "DVADJ", "Divide-Adjust", "DVADJE[c], E[d], D[b] (RRR)", "See pag.132"},
    {0x4B, 32, "DIV", "Divide", "DIVE[c], D[a], D[b] (RR)", "See pag.134"},
    {0x4B, 32, "DIV.U", "Divide Unsigned", "DIV.UE[c], D[a], D[b] (RR)", "See pag.134"},
    {0x4B, 32, "DVINIT", "Divide-Initialization Word", "DVINIT.BE[c], D[a], D[b] (RR)", "See pag.136"},
    {0x4B, 32, "DVINIT.U", "Divide-Initialization Word Unsigned", "DVINIT.BUE[c], D[a], D[b] (RR)", "See pag.137"},
    {0x4B, 32, "DVINIT.B", "Divide-Initialization Byte", "DVINIT.HE[c], D[a], D[b] (RR)", "See pag.137"},
    {0x4B, 32, "DVINIT.BU", "Divide-Initialization Byte Unsigned", "DVINIT.HUE[c], D[a], D[b] (RR)", "See pag.137"},
    {0x4B, 32, "DVINIT.H", "Divide-Initialization Half-word", "DVINITE[c], D[a], D[b] (RR)", "See pag.137"},
    {0x4B, 32, "DVINIT.HU", "Divide-Initialization Half-word Unsigned", "DVINIT.UE[c], D[a], D[b] (RR)", "See pag.137"},
    {0x6B, 32, "DVSTEP", "Divide-Step", "DVSTEPE[c], E[d], D[b] (RRR)", "See pag.139"},
    {0x6B, 32, "DVSTEP.U", "Divide-Step Unsigned", "DVSTEP.UE[c], E[d], D[b] (RRR)", "See pag.140"},
    {0x0D, 32, "ENABLE", "Enable Interrupts", "ENABLE(SYS)", "See pag.141"},
    {0x8B, 32, "EQ", "Equal", "EQD[c], D[a], const9 (RC)", "See pag.142"},
    {0x0B, 32, "EQ", "Equal", "EQD[c], D[a], D[b] (RR)", "See pag.142"},
    {0xBA, 16, "EQ", "Equal", "EQD[15], D[a], const4 (SRC)", "See pag.142"},
    {0x3A, 16, "EQ", "Equal", "EQD[15], D[a], D[b] (SRR)", "See pag.142"},
    {0x01, 32, "EQ.A", "Equal to Address", "EQ.AD[c], A[a], A[b] (RR)", "See pag.144"},
    {0x0B, 32, "EQ.B", "Equal Packed Byte", "EQ.BD[c], D[a], D[b] (RR)", "See pag.145"},
    {0x0B, 32, "EQ.H", "Equal Packed Half-word", "EQ.HD[c], D[a], D[b] (RR)", "See pag.145"},
    {0x0B, 32, "EQ.W", "Equal Packed Word", "EQ.WD[c], D[a], D[b] (RR)", "See pag.145"},
    {0x8B, 32, "EQANY.B", "Equal Any Byte", "EQANY.BD[c], D[a], const9 (RC)", "See pag.147"},
    {0x0B, 32, "EQANY.B", "Equal Any Byte", "EQANY.BD[c], D[a], D[b] (RR)", "See pag.147"},
    {0x8B, 32, "EQANY.H", "Equal Any Half-word", "EQANY.HD[c], D[a], const9 (RC)", "See pag.147"},
    {0x0B, 32, "EQANY.H", "Equal Any Half-word", "EQANY.HD[c], D[a], D[b] (RR)", "See pag.148"},
    {0x01, 32, "EQZ.A", "Equal Zero Address", "EQZ.AD[c], A[a] (RR)", "See pag.149"},
    {0x37, 32, "EXTR", "Extract Bit Field", "EXTRD[c], D[a], pos, width (RRPW)", "See pag.150"},
    {0x17, 32, "EXTR", "Extract Bit Field", "EXTRD[c], D[a], E[d] (RRRR)", "See pag.150"},
    {0x57, 32, "EXTR", "Extract Bit Field", "EXTRD[c], D[a], D[d], width (RRRW)", "See pag.150"},
    {0x37, 32, "EXTR.U", "Extract Bit Field Unsigned", "EXTR.UD[c], D[a], pos, width (RRPW)", "See pag.150"},
    {0x17, 32, "EXTR.U", "Extract Bit Field Unsigned", "EXTR.UD[c], D[a], E[d] (RRRR)", "See pag.150"},
    {0x57, 32, "EXTR.U", "Extract Bit Field Unsigned", "EXTR.UD[c], D[a], D[d], width (RRRW)", "See pag.151"},
    {0x61, 32, "FCALL", "Fast Call", "FCALLdisp24 (B)", "See pag.152"},
    {0xE1, 32, "FCALLA", "Fast Call Absolute", "FCALLAdisp24 (B)", "See pag.153"},
    {0x2D, 32, "FCALLI", "Fast Call Indirect", "FCALLIA[a] (RR)", "See pag.154"},
    {0x00, 16, "FRET", "Return from Fast Call", "FRET (SR)", "See pag.155"},
    {0x03, 32, "FRET", "Return from Fast Call", "FRET (SYS)", "See pag.155"},
    {0x8B, 32, "GE", "Greater Than or Equal", "GED[c], D[a], const9 (RC)", "See pag.156"},
    {0x0B, 32, "GE", "Greater Than or Equal", "GED[c], D[a], D[b] (RR)", "See pag.156"},
    {0x8B, 32, "GE.U", "Greater Than or Equal Unsigned", "GE.UD[c], D[a], const9 (RC)", "See pag.156"},
    {0x0B, 32, "GE.U", "Greater Than or Equal Unsigned", "GE.UD[c], D[a], D[b] (RR)", "See pag.156"},
    {0x01, 32, "GE.A", "Greater Than or Equal Address", "GE.AD[c], A[a], A[b] (RR)", "See pag.158"},
    {0xB7, 32, "IMASK", "Insert Mask", "IMASKE[c], const4, pos, width (RCPW)", "See pag.159"},
    {0xD7, 32, "IMASK", "Insert Mask", "IMASKE[c], const4, D[d], width (RCRW)", "See pag.159"},
    {0x37, 32, "IMASK", "Insert Mask", "IMASKE[c], D[b], pos, width (RRPW)", "See pag.159"},
    {0x57, 32, "IMASK", "Insert Mask", "IMASKE[c], D[b], D[d], width (RRRW)", "See pag.159"},
    {0x67, 32, "INS.T", "Insert Bit", "INS.TD[c], D[a], pos1, D[b], pos2 (BIT)", "See pag.161"},
    {0x67, 32, "INSN.T", "Insert Bit-Not", "INSN.TD[c], D[a], pos1, D[b], pos2 (BIT)", "See pag.161"},
    {0xB7, 32, "INSERT", "Insert Bit Field", "INSERTD[c], D[a], const4, pos, width (RCPW)", "See pag.162"},
    {0x97, 32, "INSERT", "Insert Bit Field", "INSERTD[c], D[a], const4, E[d] (RCRR)", "See pag.162"},
    {0xD7, 32, "INSERT", "Insert Bit Field", "INSERTD[c], D[a], const4, D[d], width (RCRW)", "See pag.162"},
    {0x37, 32, "INSERT", "Insert Bit Field", "INSERTD[c], D[a], D[b], pos, width (RRPW)", "See pag.162"},
    {0x17, 32, "INSERT", "Insert Bit Field", "INSERTD[c], D[a], D[b], E[d] (RRRR)", "See pag.163"},
    {0x57, 32, "INSERT", "Insert Bit Field", "INSERTD[c], D[a], D[b], D[d], width (RRRW)", "See pag.163"},
    {0x0D, 32, "ISYNC", "Synchronize Instructions", "ISYNC(SYS)", "See pag.164"},
    {0x6B, 32, "IXMAX", "Find Maximum Index", "IXMAXE[c], E[d], D[b] (RRR)", "See pag.165"},
    {0x6B, 32, "IXMAX.U", "Find Maximum Index (unsigned)", "IXMAX.UE[c], E[d], D[b] (RRR)", "See pag.165"},
    {0x6B, 32, "IXMIN", "Find Minimum Index", "IXMINE[c], E[d], D[b] (RRR)", "See pag.167"},
    {0x6B, 32, "IXMIN.U", "Find Minimum Index (unsigned)", "IXMIN.UE[c], E[d], D[b] (RRR)", "See pag.167"},
    {0x1D, 32, "J", "Jump Unconditional", "Jdisp24 (B)", "See pag.169"},
    {0x3C, 16, "J", "Jump Unconditional", "Jdisp8 (SB)", "See pag.169"},
    {0x9D, 32, "JA", "Jump Unconditional Absolute", "", "See pag.170"},
    {0xDF, 32, "JEQ", "Jump if Equal", "JEQD[a], const4, disp15 (BRC)", "See pag.171"},
    {0x5F, 32, "JEQ", "Jump if Equal", "JEQD[a], D[b], disp15 (BRR)", "See pag.171"},
    {0x1E, 16, "JEQ", "Jump if Equal", "JEQD[15], const4, disp4 (SBC)", "See pag.171"},
    {0x9E, 16, "JEQ", "Jump if Equal", "JEQD[15], const4, disp4 (SBC)", "See pag.171"},
    {0x3E, 16, "JEQ", "Jump if Equal", "JEQD[15], D[b], disp4 (SBR)", "See pag.171"},
    {0xBE, 16, "JEQ", "Jump if Equal", "JEQD[15], D[b], disp4 (SBR)", "See pag.172"},
    {0x7D, 32, "JEQ.A", "Jump if Equal Address", "JEQ.AA[a], A[b], disp15 (BRR)", "See pag.173"},
    {0xFF, 32, "JGE", "Jump if Greater Than or Equal", "JGED[a], const4, disp15 (BRC)", "See pag.174"},
    {0x7F, 32, "JGE", "Jump if Greater Than or Equal", "JGED[a], D[b], disp15 (BRR)", "See pag.174"},
    {0xFF, 32, "JGE.U", "Jump if Greater Than or Equal Unsigned", "JGE.UD[a], const4, disp15 (BRC)", "See pag.174"},
    {0x7F, 32, "JGE.U", "Jump if Greater Than or Equal Unsigned", "JGE.UD[a], D[b], disp15 (BRR)", "See pag.174"},
    {0xCE, 16, "JGEZ", "Jump if Greater Than or Equal to Zero (16-bit)", "JGEZD[b], disp4 (SBR)", "See pag.176"},
    {0x4E, 16, "JGTZ", "Jump if Greater Than Zero (16-bit)", "JGTZD[b], disp4 (SBR)", "See pag.177"},
    {0x2D, 32, "JI", "Jump Indirect", "JIA[a] (RR)", "See pag.178"},
    {0xDC, 16, "JI", "Jump Indirect", "JIA[a] (SR)", "See pag.178"},
    {0x5D, 32, "JL", "Jump and Link", "JLdisp24 (B)", "See pag.179"},
    {0xDD, 32, "JLA", "Jump and Link Absolute", "JLAdisp24 (B)", "See pag.180"},
    {0x8E, 16, "JLEZ", "Jump if Less Than or Equal to Zero (16-bit)", "JLEZD[b], disp4 (SBR)", "See pag.181"},
    {0x2D, 32, "JLI", "Jump and Link Indirect", "JLIA[a] (RR)", "See pag.182"},
    {0xBF, 32, "JLT", "Jump if Less Than", "JLTD[a], const4, disp15 (BRC)", "See pag.183"},
    {0x3F, 32, "JLT", "Jump if Less Than", "JLTD[a], D[b], disp15 (BRR)", "See pag.183"},
    {0xBF, 32, "JLT.U", "Jump if Less Than Unsigned", "JLT.UD[a], const4, disp15 (BRC)", "See pag.183"},
    {0x3F, 32, "JLT.U", "Jump if Less Than Unsigned", "JLT.UD[a], D[b], disp15 (BRR)", "See pag.183"},
    {0x0E, 16, "JLTZ", "Jump if Less Than Zero (16-bit)", "JLTZD[b], disp4 (SBR)", "See pag.185"},
    {0xDF, 32, "JNE", "Jump if Not Equal", "JNED[a], const4, disp15 (BRC)", "See pag.186"},
    {0x5F, 32, "JNE", "Jump if Not Equal", "JNED[a], D[b], disp15 (BRR)", "See pag.186"},
    {0x5E, 16, "JNE", "Jump if Not Equal", "JNED[15], const4, disp4 (SBC)", "See pag.186"},
    {0xDE, 16, "JNE", "Jump if Not Equal", "JNED[15], const4, disp4 (SBC)", "See pag.186"},
    {0x7E, 16, "JNE", "Jump if Not Equal", "JNED[15], D[b], disp4 (SBR)", "See pag.186"},
    {0xFE, 16, "JNE", "Jump if Not Equal", "JNED[15], D[b], disp4 (SBR)", "See pag.187"},
    {0x7D, 32, "JNE.A", "Jump if Not Equal Address", "JNE.AA[a], A[b], disp15 (BRR)", "See pag.188"},
    {0x9F, 32, "JNED", "Jump if Not Equal and Decrement", "JNEDD[a], const4, disp15 (BRC)", "See pag.189"},
    {0x1F, 32, "JNED", "Jump if Not Equal and Decrement", "JNEDD[a], D[b], disp15 (BRR)", "See pag.189"},
    {0x9F, 32, "JNEI", "Jump if Not Equal and Increment", "JNEID[a], const4, disp15 (BRC)", "See pag.190"},
    {0x1F, 32, "JNEI", "Jump if Not Equal and Increment", "JNEID[a], D[b], disp15 (BRR)", "See pag.190"},
    {0xEE, 16, "JNZ", "Jump if Not Equal to Zero (16-bit)", "JNZD[15], disp8 (SB)", "See pag.191"},
    {0xF6, 16, "JNZ", "Jump if Not Equal to Zero (16-bit)", "JNZD[b], disp4 (SBR)", "See pag.191"},
    {0xBD, 32, "JNZ.A", "Jump if Not Equal to Zero Address", "JNZ.AA[a], disp15 (BRR)", "See pag.192"},
    {0x7C, 16, "JNZ.A", "Jump if Not Equal to Zero Address", "JNZ.AA[b], disp4 (SBR)", "See pag.192"},
    {0x6F, 32, "JNZ.T", "Jump if Not Equal to Zero Bit", "JNZ.TD[a], n, disp15 (BRN)", "See pag.193"},
    {0xAE, 16, "JNZ.T", "Jump if Not Equal to Zero Bit", "JNZ.TD[15], n, disp4 (SBRN)", "See pag.193"},
    {0x6E, 16, "JZ", "Jump if Zero (16-bit)", "JZD[15], disp8 (SB)", "See pag.194"},
    {0x76, 16, "JZ", "Jump if Zero (16-bit)", "JZD[b], disp4 (SBR)", "See pag.194"},
    {0xBD, 32, "JZ.A", "Jump if Zero Address", "JZ.AA[a], disp15 (BRR)", "See pag.195"},
    {0xBC, 16, "JZ.A", "Jump if Zero Address", "JZ.AA[b], disp4 (SBR)", "See pag.195"},
    {0x6F, 32, "JZ.T", "Jump if Zero Bit", "JZ.TD[a], n, disp15 (BRN)", "See pag.196"},
    {0x2E, 16, "JZ.T", "Jump if Zero Bit", "JZ.TD[15], n, disp4 (SBRN)", "See pag.196"},
    {0x85, 32, "LD.A", "Load Word to Address Register", "LD.AA[a], off18 (ABS)(Absolute Addressing Mode", "See pag.197"},
    {0x09, 32, "LD.A", "Load Word to Address Register", "LD.AA[a], A[b], off10 (BO)(Base + Short Offset", "See pag.197"},
    {0x29, 32, "LD.A", "Load Word to Address Register", "LD.AA[a], P[b] (BO)(Bit-reverse Addressing Mod", "See pag.197"},
    {0x29, 32, "LD.A", "Load Word to Address Register", "LD.AA[a], P[b], off10 (BO)(Circular Addressing", "See pag.197"},
    {0x09, 32, "LD.A", "Load Word to Address Register", "LD.AA[a], A[b], off10 (BO)(Post-increment Addr", "See pag.198"},
    {0x09, 32, "LD.A", "Load Word to Address Register", "LD.AA[a], A[b], off10 (BO)(Pre-increment Addre", "See pag.198"},
    {0x99, 32, "LD.A", "Load Word to Address Register", "LD.AA[a], A[b], off16 (BOL)(Base + Long Offset", "See pag.198"},
    {0xD8, 16, "LD.A", "Load Word to Address Register", "LD.AA[15], A[10], const8 (SC)", "See pag.198"},
    {0xD4, 16, "LD.A", "Load Word to Address Register", "LD.AA[c], A[b] (SLR)", "See pag.198"},
    {0xC4, 16, "LD.A", "Load Word to Address Register", "LD.AA[c], A[b] (SLR)(Post-increment Addressing", "See pag.198"},
    {0xC8, 16, "LD.A", "Load Word to Address Register", "LD.AA[c], A[15], off4 (SLRO)", "See pag.199"},
    {0xCC, 16, "LD.A", "Load Word to Address Register", "LD.AA[15], A[b], off4 (SRO)", "See pag.199"},
    {0x05, 32, "LD.B", "Load Byte", "LD.BD[a], off18 (ABS)(Absolute Addressing Mode", "See pag.200"},
    {0x09, 32, "LD.B", "Load Byte", "LD.BD[a], A[b], off10 (BO)(Base + Short Offset", "See pag.200"},
    {0x29, 32, "LD.B", "Load Byte", "LD.BD[a], P[b] (BO)(Bit-reverse Addressing Mod", "See pag.200"},
    {0x29, 32, "LD.B", "Load Byte", "LD.BD[a], P[b], off10 (BO)(Circular Addressing", "See pag.200"},
    {0x09, 32, "LD.B", "Load Byte", "LD.BD[a], A[b], off10 (BO)(Post-increment Addr", "See pag.201"},
    {0x09, 32, "LD.B", "Load Byte", "LD.BD[a], A[b], off10 (BO)(Pre-increment Addre", "See pag.201"},
    {0x79, 32, "LD.B", "Load Byte", "LD.BD[a], A[b], off16 (BOL)(Base + Long Offset", "See pag.201"},
    {0x05, 32, "LD.BU", "Load Byte Unsigned", "LD.BUD[a], off18 (ABS)(Absolute Addressing Mod", "See pag.201"},
    {0x09, 32, "LD.BU", "Load Byte Unsigned", "LD.BUD[a], A[b], off10 (BO)(Base + Short Offse", "See pag.201"},
    {0x29, 32, "LD.BU", "Load Byte Unsigned", "LD.BUD[a], P[b] (BO)(Bit-reverse Addressing Mo", "See pag.201"},
    {0x29, 32, "LD.BU", "Load Byte Unsigned", "LD.BUD[a], P[b], off10 (BO)(Circular Addressin", "See pag.202"},
    {0x09, 32, "LD.BU", "Load Byte Unsigned", "LD.BUD[a], A[b], off10 (BO)(Post-increment Add", "See pag.202"},
    {0x09, 32, "LD.BU", "Load Byte Unsigned", "LD.BUD[a], A[b], off10 (BO)(Pre-increment Addr", "See pag.202"},
    {0x39, 32, "LD.BU", "Load Byte Unsigned", "LD.BUD[a], A[b], off16 (BOL)(Base + Long Offse", "See pag.202"},
    {0x14, 16, "LD.BU", "Load Byte Unsigned", "LD.BUD[c], A[b] (SLR)", "See pag.203"},
    {0x04, 16, "LD.BU", "Load Byte Unsigned", "LD.BUD[c], A[b] (SLR)(Post-increment Addressin", "See pag.203"},
    {0x08, 16, "LD.BU", "Load Byte Unsigned", "LD.BUD[c], A[15], off4 (SLRO)", "See pag.203"},
    {0x0C, 16, "LD.BU", "Load Byte Unsigned", "LD.BUD[15], A[b], off4 (SRO)", "See pag.203"},
    {0x85, 32, "LD.D", "Load Double-word", "LD.DE[a], off18 (ABS)(Absolute Addressing Mode", "See pag.204"},
    {0x09, 32, "LD.D", "Load Double-word", "LD.DE[a], A[b], off10 (BO)(Base + Short Offset", "See pag.204"},
    {0x29, 32, "LD.D", "Load Double-word", "LD.DE[a], P[b] (BO)(Bit-reverse Addressing Mod", "See pag.204"},
    {0x29, 32, "LD.D", "Load Double-word", "LD.DE[a], P[b], off10 (BO)(Circular Addressing", "See pag.204"},
    {0x09, 32, "LD.D", "Load Double-word", "LD.DE[a], A[b], off10 (BO)(Post-increment Addr", "See pag.205"},
    {0x09, 32, "LD.D", "Load Double-word", "LD.DE[a], A[b], off10 (BO)(Pre-increment Addre", "See pag.205"},
    {0x85, 32, "LD.DA", "Load Double-word to Address Register", "LD.DAP[a], off18 (ABS)(Absolute Addressing Mod", "See pag.206"},
    {0x09, 32, "LD.DA", "Load Double-word to Address Register", "LD.DA P[a], A[b], off10 (BO)(Base + Short Offs", "See pag.206"},
    {0x29, 32, "LD.DA", "Load Double-word to Address Register", "LD.DAP[a], P[b] (BO)(Bit-reverse Addressing Mo", "See pag.206"},
    {0x29, 32, "LD.DA", "Load Double-word to Address Register", "LD.DAP[a], P[b], off10 (BO)(Circular Addressin", "See pag.206"},
    {0x09, 32, "LD.DA", "Load Double-word to Address Register", "LD.DA P[a], A[b], off10 (BO)(Post-increment Ad", "See pag.207"},
    {0x09, 32, "LD.DA", "Load Double-word to Address Register", "LD.DA P[a], A[b], off10 (BO)(Pre-increment Add", "See pag.207"},
    {0x05, 32, "LD.H", "Load Half-word", "LD.HD[a], off18 (ABS)(Absolute Addressing Mode", "See pag.208"},
    {0x09, 32, "LD.H", "Load Half-word", "LD.HD[a], A[b], off10 (BO)(Base + Short Offset", "See pag.208"},
    {0x29, 32, "LD.H", "Load Half-word", "LD.HD[a], P[b] (BO)(Bit-reverse Addressing Mod", "See pag.208"},
    {0x29, 32, "LD.H", "Load Half-word", "LD.HD[a], P[b], off10 (BO)(Circular Addressing", "See pag.208"},
    {0x09, 32, "LD.H", "Load Half-word", "LD.HD[a], A[b], off10 (BO)(Post-increment Addr", "See pag.209"},
    {0x09, 32, "LD.H", "Load Half-word", "LD.HD[a], A[b], off10 (BO)(Pre-increment Addre", "See pag.209"},
    {0xC9, 32, "LD.H", "Load Half-word", "LD.HD[a], A[b], off16 (BOL)(Base + Long Offset", "See pag.209"},
    {0x94, 16, "LD.H", "Load Half-word", "LD.HD[c], A[b] (SLR)", "See pag.209"},
    {0x84, 16, "LD.H", "Load Half-word", "LD.HD[c], A[b] (SLR)(Post-increment Addressing", "See pag.209"},
    {0x88, 16, "LD.H", "Load Half-word", "LD.HD[c], A[15], off4 (SLRO)", "See pag.209"},
    {0x8C, 16, "LD.H", "Load Half-word", "LD.HD[15], A[b], off4 (SRO)", "See pag.210"},
    {0x05, 32, "LD.HU", "Load Half-word Unsigned", "LD.HUD[a], off18 (ABS)(Absolute Addressing Mod", "See pag.210"},
    {0x09, 32, "LD.HU", "Load Half-word Unsigned", "LD.HUD[a], A[b], off10 (BO)(Base + Short Offse", "See pag.210"},
    {0x29, 32, "LD.HU", "Load Half-word Unsigned", "LD.HUD[a], P[b] (BO)(Bit-reverse Addressing Mo", "See pag.210"},
    {0x29, 32, "LD.HU", "Load Half-word Unsigned", "LD.HUD[a], P[b], off10 (BO)(Circular Addressin", "See pag.210"},
    {0x09, 32, "LD.HU", "Load Half-word Unsigned", "LD.HUD[a], A[b], off10 (BO)(Post-increment Add", "See pag.211"},
    {0x09, 32, "LD.HU", "Load Half-word Unsigned", "LD.HUD[a], A[b], off10 (BO)(Pre-increment Addr", "See pag.211"},
    {0xB9, 32, "LD.HU", "Load Half-word Unsigned", "LD.HUD[a], A[b], off16 (BOL)(Base + Long Offse", "See pag.211"},
    {0x45, 32, "LD.Q", "Load Half-word Signed Fraction", "LD.QD[a], off18 (ABS)(Absolute Addressing Mode", "See pag.212"},
    {0x09, 32, "LD.Q", "Load Half-word Signed Fraction", "LD.QD[a], A[b], off10 (BO)(Base + Short Offset", "See pag.212"},
    {0x29, 32, "LD.Q", "Load Half-word Signed Fraction", "LD.QD[a], P[b] (BO)(Bit-reverse Addressing Mod", "See pag.212"},
    {0x29, 32, "LD.Q", "Load Half-word Signed Fraction", "LD.QD[a], P[b], off10 (BO)(Circular Addressing", "See pag.212"},
    {0x09, 32, "LD.Q", "Load Half-word Signed Fraction", "LD.QD[a], A[b], off10 (BO)(Post-increment Addr", "See pag.213"},
    {0x09, 32, "LD.Q", "Load Half-word Signed Fraction", "LD.QD[a], A[b], off10 (BO)(Pre-increment Addre", "See pag.213"},
    {0x85, 32, "LD.W", "Load Word", "LD.WD[a], off18 (ABS)(Absolute Addressing Mode", "See pag.214"},
    {0x09, 32, "LD.W", "Load Word", "LD.WD[a], A[b], off10 (BO)(Base + Short Offset", "See pag.214"},
    {0x29, 32, "LD.W", "Load Word", "LD.WD[a], P[b] (BO)(Bit-reverse Addressing Mod", "See pag.214"},
    {0x29, 32, "LD.W", "Load Word", "LD.WD[a], P[b], off10 (BO)(Circular Addressing", "See pag.214"},
    {0x09, 32, "LD.W", "Load Word", "LD.WD[a], A[b], off10 (BO)(Post-increment Addr", "See pag.215"},
    {0x09, 32, "LD.W", "Load Word", "LD.WD[a], A[b], off10 (BO)(Pre-increment Addre", "See pag.215"},
    {0x19, 32, "LD.W", "Load Word", "LD.WD[a], A[b], off16 (BOL)(Base + Long Offset", "See pag.215"},
    {0x58, 16, "LD.W", "Load Word", "LD.WD[15], A[10], const8 (SC)", "See pag.215"},
    {0x54, 16, "LD.W", "Load Word", "LD.WD[c], A[b] (SLR)", "See pag.215"},
    {0x44, 16, "LD.W", "Load Word", "LD.WD[c], A[b] (SLR)(Post-increment Addressing", "See pag.215"},
    {0x48, 16, "LD.W", "Load Word", "LD.WD[c], A[15], off4 (SLRO)", "See pag.216"},
    {0x4C, 16, "LD.W", "Load Word", "LD.WD[15], A[b], off4 (SRO)", "See pag.216"},
    {0x15, 32, "LDLCX", "Load Lower Context", "LDLCXoff18 (ABS)(Absolute Addressing Mode)", "See pag.217"},
    {0x49, 32, "LDLCX", "Load Lower Context", "LDLCXA[b], off10 (BO) (Base + Short Index Addr", "See pag.217"},
    {0xE5, 32, "LDMST", "Load-Modify-Store", "LDMSToff18, E[a] (ABS)(Absolute Addressing Mod", "See pag.218"},
    {0x49, 32, "LDMST", "Load-Modify-Store", "LDMSTA[b], off10, E[a] (BO)(Base + Short Offse", "See pag.218"},
    {0x69, 32, "LDMST", "Load-Modify-Store", "LDMSTP[b], E[a] (BO)(Bit-reverse Addressing Mo", "See pag.218"},
    {0x69, 32, "LDMST", "Load-Modify-Store", "LDMSTP[b], off10, E[a] (BO)(Circular Addressin", "See pag.218"},
    {0x49, 32, "LDMST", "Load-Modify-Store", "LDMSTA[b], off10, E[a] (BO)(Post-increment Add", "See pag.219"},
    {0x49, 32, "LDMST", "Load-Modify-Store", "LDMSTA[b], off10, E[a] (BO)(Pre-increment Addr", "See pag.219"},
    {0x15, 32, "LDUCX", "Load Upper Context", "LDUCXoff18 (ABS)(Absolute Addressing Mode)", "See pag.220"},
    {0x49, 32, "LDUCX", "Load Upper Context", "LDUCXA[b], off10 (BO)(Base + Short Index Addre", "See pag.220"},
    {0xC5, 32, "LEA", "Load Effective Address", "LEAA[a], off18 (ABS)(Absolute Addressing Mode)", "See pag.221"},
    {0x49, 32, "LEA", "Load Effective Address", "LEAA[a], A[b], off10 (BO)(Base + Short Offset", "See pag.221"},
    {0xD9, 32, "LEA", "Load Effective Address", "LEAA[a], A[b], off16 (BOL)(Base + Long Offset", "See pag.221"},
    {0xFD, 32, "LOOP", "Loop", "LOOPA[b], disp15 (BRR)", "See pag.222"},
    {0xFC, 16, "LOOP", "Loop", "LOOPA[b], disp4 (SBR)", "See pag.222"},
    {0xFD, 32, "LOOPU", "Loop Unconditional", "LOOPUdisp15 (BRR)", "See pag.223"},
    {0x8B, 32, "LT", "Less Than", "LTD[c], D[a], const9 (RC)", "See pag.224"},
    {0x0B, 32, "LT", "Less Than", "LTD[c], D[a], D[b] (RR)", "See pag.224"},
    {0xFA, 16, "LT", "Less Than", "LTD[15], D[a], const4 (SRC)", "See pag.224"},
    {0x7A, 16, "LT", "Less Than", "LTD[15], D[a], D[b] (SRR)", "See pag.224"},
    {0x8B, 32, "LT.U", "Less Than Unsigned", "LT.UD[c], D[a], const9 (RC)", "See pag.225"},
    {0x0B, 32, "LT.U", "Less Than Unsigned", "LT.UD[c], D[a], D[b] (RR)", "See pag.225"},
    {0x01, 32, "LT.A", "Less Than Address", "LT.AD[c], A[a], A[b] (RR)", "See pag.226"},
    {0x0B, 32, "LT.B", "Less Than Packed Byte", "LT.BD[c], D[a], D[b] (RR)", "See pag.227"},
    {0x0B, 32, "LT.BU", "Less Than Packed Byte Unsigned", "LT.BUD[c], D[a], D[b] (RR)", "See pag.227"},
    {0x0B, 32, "LT.H", "Less Than Packed Half-word", "LT.HD[c], D[a], D[b] (RR)", "See pag.228"},
    {0x0B, 32, "LT.HU", "Less Than Packed Half-word Unsigned", "LT.HUD[c], D[a], D[b] (RR)", "See pag.228"},
    {0x0B, 32, "LT.W", "Less Than Packed Word", "LT.WD[c], D[a], D[b] (RR)", "See pag.229"},
    {0x0B, 32, "LT.WU", "Less Than Packed Word Unsigned", "LT.WUD[c], D[a], D[b] (RR)", "See pag.229"},
    {0x13, 32, "MADD", "Multiply-Add", "MADDD[c], D[d], D[a], const9 (RCR)", "See pag.230"},
    {0x13, 32, "MADD", "Multiply-Add", "MADDE[c], E[d], D[a], const9 (RCR)", "See pag.230"},
    {0x03, 32, "MADD", "Multiply-Add", "MADDD[c], D[d], D[a], D[b] (RRR2)", "See pag.230"},
    {0x03, 32, "MADD", "Multiply-Add", "MADDE[c], E[d], D[a], D[b] (RRR2)", "See pag.230"},
    {0x13, 32, "MADDS", "Multiply-Add, Saturated", "MADDSD[c], D[d], D[a], const9 (RCR)", "See pag.231"},
    {0x13, 32, "MADDS", "Multiply-Add, Saturated", "MADDSE[c], E[d], D[a], const9 (RCR)", "See pag.231"},
    {0x03, 32, "MADDS", "Multiply-Add, Saturated", "MADDSD[c], D[d], D[a], D[b] (RRR2)", "See pag.231"},
    {0x03, 32, "MADDS", "Multiply-Add, Saturated", "MADDSE[c], E[d], D[a], D[b] (RRR2)", "See pag.231"},


    {0xFF, 32, "Mnemo", "Longname", "syntax", "Description"},
};

/******************************************************************************
** FUNCTION PROTOTYPES                                                       **
******************************************************************************/


#ifdef __cplusplus
}
#endif
//****************************************************************************
//                                 END OF FILE
//****************************************************************************


#endif // __TC1_6_h

